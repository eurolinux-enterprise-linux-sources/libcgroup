From a6bbad2768c3dbebdefd12d21053ed855f5dec0d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Nikola=20Forr=C3=B3?= <nforro@redhat.com>
Date: Mon, 6 Feb 2017 13:06:51 +0100
Subject: [PATCH] libcgroup-0.40.rc1-reading-config-files-from-etc-cgc

---
 doc/man/cgconfig.conf.5    |  12 ++-
 doc/man/cgrulesengd.8      |   8 +-
 include/libcgroup/config.h |  33 ++++++
 scripts/init.d/cgconfig.in |   5 +-
 src/Makefile.am            |   2 +-
 src/Makefile.in            |  19 +++-
 src/config.c               | 254 ++++++++++++++++++++++++++++++++++++++++++++-
 src/daemon/cgrulesengd.c   |  28 +++--
 src/libcgroup-internal.h   |   3 +
 src/libcgroup.map          |   7 ++
 src/pam/pam_cgroup.c       |  18 ++++
 src/tools/tools-common.h   |   2 +-
 12 files changed, 369 insertions(+), 22 deletions(-)

diff --git a/doc/man/cgconfig.conf.5 b/doc/man/cgconfig.conf.5
index be80e4e..79afcd6 100644
--- a/doc/man/cgconfig.conf.5
+++ b/doc/man/cgconfig.conf.5
@@ -251,6 +251,9 @@ Templates does not use
 .B default
 section settings.
 
+.I /etc/cgconfig.d/
+directory can be used for additional configuration files. cgrulesengd searches this directory for additional templates.
+
 .\"********************************************"
 .SH EXAMPLES
 .LP
@@ -783,10 +786,15 @@ related to them.
 .SH FILES
 .LP
 .PD .1v
-.TP 20
-.B /etc/cgconfig.conf
 .TP
+.B /etc/cgconfig.conf
+.RS 4
 default libcgroup configuration file
+.RE
+.B /etc/cgconfig.d/
+.RS 4
+default libcgroup configuration files directory
+.RE
 .PD 
 
 .SH SEE ALSO
diff --git a/doc/man/cgrulesengd.8 b/doc/man/cgrulesengd.8
index 2e89c5b..749b6fc 100644
--- a/doc/man/cgrulesengd.8
+++ b/doc/man/cgrulesengd.8
@@ -65,10 +65,16 @@ controls verbosity of the tool. Allowed values are \fBDEBUG\fR,
 .SH FILES
 .LP
 .PD .1v
-.TP 20
+.TP
 .B /etc/cgrules.conf
 .TP
 the default libcgroup configuration file
+.TP
+.B /etc/cgconfig.conf
+the default templates file
+.TP
+.B /etc/cgconfig.d/
+the default templates directory
 
 .SH SEE ALSO
 cgrules.conf (5)
diff --git a/include/libcgroup/config.h b/include/libcgroup/config.h
index 43568e1..eadf723 100644
--- a/include/libcgroup/config.h
+++ b/include/libcgroup/config.h
@@ -84,11 +84,32 @@ int cgroup_init_templates_cache(char *pathname);
 int cgroup_reload_cached_templates(char *pathname);
 
 /**
+ * Load the templates cache from files. Before calling this function,
+ * cgroup_templates_cache_set_source_files has to be called first.
+ * @param file_index index of file which was unable to be parsed
+ * @return 0 on success, > 0 on error
+ */
+int cgroup_load_templates_cache_from_files(int *file_index);
+
+/**
+ * Setting source files of templates. This function has to be called before
+ * any call of cgroup_load_templates_cache_from_files.
+ * @param tmpl_files
+ */
+struct cgroup_string_list;
+void cgroup_templates_cache_set_source_files(
+	struct cgroup_string_list *tmpl_files);
+
+/**
  * Physically create a new control group in kernel, based on given control
  * group template and configuration file. If given template is not set in
  * configuration file, then the procedure works create the control group
  * using  cgroup_create_cgroup() function
  *
+ * Templates are loaded using cgroup_[init|reload]_templates_cache_from_files
+ * function, which must be preceded by cgroup_templates_cache_set_source_files
+ * call.
+ *
  * The flags can alter the behavior of this function:
  * CGFLAG_USE_TEMPLATE_CACHE: Use cached templates instead of
  * parsing the config file
@@ -104,6 +125,18 @@ int cgroup_config_create_template_group(
 	int flags);
 
 /**
+ * Initialize and load template rules from /etc/cgconfig.conf
+ * and /etc/cgconfig.d directory
+ */
+int cgroup_init_template_files(struct cgroup_string_list **tmpl_files,
+		int *fileindex, char *program_name);
+
+/**
+ * Free list of template config files
+ */
+void cgroup_free_template_files(struct cgroup_string_list **tmpl_files);
+
+/**
  * @}
  * @}
  */
diff --git a/scripts/init.d/cgconfig.in b/scripts/init.d/cgconfig.in
index ec89454..9c1c617 100644
--- a/scripts/init.d/cgconfig.in
+++ b/scripts/init.d/cgconfig.in
@@ -33,6 +33,7 @@
 prefix=@prefix@;exec_prefix=@exec_prefix@;sbindir=@sbindir@
 CGCONFIGPARSER_BIN=$sbindir/cgconfigparser
 CONFIG_FILE=/etc/cgconfig.conf
+CONFIG_DIR=/etc/cgconfig.d
 servicename=cgconfig
 lockfile=/var/lock/subsys/$servicename
 
@@ -117,10 +118,10 @@ start() {
                     return 6
                 fi
 
-                $CGCONFIGPARSER_BIN -l $CONFIG_FILE
+                $CGCONFIGPARSER_BIN -l $CONFIG_FILE -L $CONFIG_DIR
                 retval=$?
                 if [ $retval -ne 0 ]; then
-                    log_failure_msg "Failed to parse " $CONFIG_FILE
+                    log_failure_msg "Failed to parse " $CONFIG_FILE " or " $CONFIG_DIR
                     return 1
                 fi
         fi
diff --git a/src/Makefile.am b/src/Makefile.am
index 3a92d59..041bc7d 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -11,7 +11,7 @@ CLEANFILES = lex.c parse.c parse.h
 
 INCLUDES = -I$(top_srcdir)/include
 lib_LTLIBRARIES = libcgroup.la
-libcgroup_la_SOURCES = parse.h parse.y lex.l api.c config.c libcgroup-internal.h libcgroup.map wrapper.c log.c
+libcgroup_la_SOURCES = parse.h parse.y lex.l api.c config.c libcgroup-internal.h libcgroup.map wrapper.c log.c tools/tools-common.c tools/tools-common.h
 libcgroup_la_LIBADD = -lpthread
 libcgroup_la_LDFLAGS = -Wl,--version-script,$(srcdir)/libcgroup.map \
 	-version-number $(LIBRARY_VERSION_MAJOR):$(LIBRARY_VERSION_MINOR):$(LIBRARY_VERSION_RELEASE)
diff --git a/src/Makefile.in b/src/Makefile.in
index 3d0e1a8..d355c42 100644
--- a/src/Makefile.in
+++ b/src/Makefile.in
@@ -93,7 +93,7 @@ am__installdirs = "$(DESTDIR)$(libdir)"
 LTLIBRARIES = $(lib_LTLIBRARIES)
 libcgroup_la_DEPENDENCIES =
 am_libcgroup_la_OBJECTS = parse.lo lex.lo api.lo config.lo wrapper.lo \
-	log.lo
+	log.lo tools-common.lo
 libcgroup_la_OBJECTS = $(am_libcgroup_la_OBJECTS)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
@@ -338,7 +338,7 @@ AM_YFLAGS = -d
 CLEANFILES = lex.c parse.c parse.h
 INCLUDES = -I$(top_srcdir)/include
 lib_LTLIBRARIES = libcgroup.la
-libcgroup_la_SOURCES = parse.h parse.y lex.l api.c config.c libcgroup-internal.h libcgroup.map wrapper.c log.c
+libcgroup_la_SOURCES = parse.h parse.y lex.l api.c config.c libcgroup-internal.h libcgroup.map wrapper.c log.c tools/tools-common.c tools/tools-common.h
 libcgroup_la_LIBADD = -lpthread
 libcgroup_la_LDFLAGS = -Wl,--version-script,$(srcdir)/libcgroup.map \
 	-version-number $(LIBRARY_VERSION_MAJOR):$(LIBRARY_VERSION_MINOR):$(LIBRARY_VERSION_RELEASE)
@@ -429,6 +429,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/log.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/parse.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/wrapper.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tools-common.Plo@am__quote@
 
 .c.o:
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
@@ -457,6 +458,20 @@ distclean-compile:
 .y.c:
 	$(AM_V_YACC)$(am__skipyacc) $(SHELL) $(YLWRAP) $< y.tab.c $@ y.tab.h `echo $@ | $(am__yacc_c2h)` y.output $*.output -- $(YACCCOMPILE)
 
+tools-common.obj: tools/tools-common.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT tools-common.obj -MD -MP -MF $(DEPDIR)/tools-common.Tpo -c -o tools-common.obj `if test -f 'tools/tools-common.c'; then $(CYGPATH_W) 'tools/tools-common.c'; else $(CYGPATH_W) '$(srcdir)/tools/tools-common.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/tools-common.Tpo $(DEPDIR)/tools-common.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='tools/tools-common.c' object='tools-common.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c -o tools-common.obj `if test -f 'tools/tools-common.c'; then $(CYGPATH_W) 'tools/tools-common.c'; else $(CYGPATH_W) '$(srcdir)/tools/tools-common.c'; fi`
+
+tools-common.lo: tools/tools-common.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LTCOMPILE) -MT tools-common.lo -MD -MP -MF $(DEPDIR)/tools-common.Tpo -c -o tools-common.lo `test -f 'tools/tools-common.c' || echo '$(srcdir)/'`tools/tools-common.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/tools-common.Tpo $(DEPDIR)/tools-common.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='tools/tools-common.c' object='tools-common.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LTCOMPILE) -c -o tools-common.lo `test -f 'tools/tools-common.c' || echo '$(srcdir)/'`tools/tools-common.c
+
 mostlyclean-libtool:
 	-rm -f *.lo
 
diff --git a/src/config.c b/src/config.c
index 24ed8e4..87df8ec 100644
--- a/src/config.c
+++ b/src/config.c
@@ -41,6 +41,8 @@
 #include <sys/stat.h>
 #include <sys/types.h>
 
+#include "tools/tools-common.h"
+
 unsigned int MAX_CGROUPS = 64;	/* NOTE: This value changes dynamically */
 unsigned int MAX_TEMPLATES = 64;
 				/* NOTE: This value changes dynamically */
@@ -89,6 +91,7 @@ static int config_template_table_index;
  */
 static struct cgroup *template_table;
 static int template_table_index;
+static struct cgroup_string_list *template_files;
 
 
 /*
@@ -96,6 +99,9 @@ static int template_table_index;
  */
 #define CGROUP_FILESYSTEM "cgroup"
 
+#define TEMPLATE_ACTION_INIT 0
+#define TEMPLATE_ACTION_RELOAD 1
+
 /*
  * NOTE: All these functions return 1 on success
  * and not 0 as is the library convention
@@ -1572,6 +1578,168 @@ int cgroup_init_templates_cache(char *pathname)
 
 }
 
+/**
+ * Setting source files of templates. This function has to be called before
+ * any call of cgroup_load_templates_cache_from_files.
+ * @param tmpl_files
+ */
+void cgroup_templates_cache_set_source_files(
+	struct cgroup_string_list *tmpl_files)
+{
+	template_files = tmpl_files;
+}
+
+/**
+ * Appending cgroup templates parsed by parser to template_table
+ * @param offset number of templates already in the table
+ */
+int cgroup_add_cgroup_templates(int offset)
+{
+	int i, ti, ret;
+
+	for (i = 0; i < config_template_table_index; i++) {
+		ti = i + offset;
+		ret = cgroup_copy_cgroup(&template_table[ti],
+			&config_template_table[i]);
+		if (ret)
+			return ret;
+
+		strcpy((template_table[ti]).name,
+			(config_template_table[i]).name);
+		template_table[ti].tasks_uid =
+			config_template_table[i].tasks_uid;
+		template_table[ti].tasks_gid =
+			config_template_table[i].tasks_gid;
+		template_table[ti].task_fperm =
+			config_template_table[i].task_fperm;
+		template_table[ti].control_uid =
+			config_template_table[i].control_uid;
+		template_table[ti].control_gid =
+			config_template_table[i].control_gid;
+		template_table[ti].control_fperm =
+			config_template_table[i].control_fperm;
+		template_table[ti].control_dperm =
+			config_template_table[i].control_dperm;
+	}
+
+	return 0;
+}
+
+/**
+ * Expand template table based on new number of parsed templates, i.e.
+ * on value of config_template_table_index.
+ * Change value of template_table_index.
+ * @return 0 on success, < 0 on error
+ */
+int cgroup_expand_template_table(void)
+{
+	int i;
+
+	template_table = realloc(template_table,
+		(template_table_index + config_template_table_index)
+		*sizeof(struct cgroup));
+
+	if (template_table == NULL)
+		return -ECGOTHER;
+
+	for (i = 0; i < config_template_table_index; i++)
+		template_table[i + template_table_index].index = 0;
+
+	template_table_index += config_template_table_index;
+
+	return 0;
+}
+
+/**
+ * Load the templates cache from files. Before calling this function,
+ * cgroup_templates_cache_set_source_files has to be called first.
+ * @param file_index index of file which was unable to be parsed
+ * @return 0 on success, > 0 on error
+ */
+int cgroup_load_templates_cache_from_files(int *file_index)
+{
+	int ret;
+	int i, j;
+	int template_table_last_index;
+	char *pathname;
+
+	if (!template_files) {
+		/* source files has not been set */
+		cgroup_dbg("Template source files have not been set\n");
+		ret = ECGOTHER;
+		*file_index = -1;
+		return ret;
+	}
+
+	/* Back compatibility with old cgroup copy function */
+	if (template_files->count == 1 &&
+		strcmp(template_files->items[0], CGCONFIG_CONF_FILE) == 0) {
+
+		if (template_table_index == 0)
+			/* the rules cache is empty */
+			return cgroup_init_templates_cache(
+				CGCONFIG_CONF_FILE);
+		else
+			/* cache is not empty */
+			return cgroup_reload_cached_templates(
+				CGCONFIG_CONF_FILE);
+	}
+
+	if (template_table) {
+		/* template structures have to be free */
+		for (i = 0; i < template_table_index; i++)
+			cgroup_free_controllers(&template_table[i]);
+		free(template_table);
+		template_table = NULL;
+	}
+	template_table_index = 0;
+
+	if ((config_template_table_index != 0) || (config_table_index != 0)) {
+		/* config structures have to be clean before parsing */
+		cgroup_free_config();
+	}
+
+	for (j = 0; j < template_files->count; j++) {
+		pathname = template_files->items[j];
+
+		cgroup_dbg("Parsing templates from %s.\n", pathname);
+		/* Attempt to read the configuration file
+		 * and cache the rules. */
+		ret = cgroup_parse_config(pathname);
+		if (ret) {
+			cgroup_dbg("Could not initialize rule cache, ");
+			cgroup_dbg("error was: %d\n", ret);
+			*file_index = j;
+			return ret;
+		}
+
+		if (config_template_table_index > 0) {
+			template_table_last_index = template_table_index;
+			ret = cgroup_expand_template_table();
+			if (ret) {
+				cgroup_dbg("Could not expand template table, ");
+				cgroup_dbg("error was: %d\n", -ret);
+				*file_index = j;
+				return -ret;
+			}
+
+			/* copy template data to templates cache structures */
+			cgroup_dbg("Copying templates to template table ");
+			cgroup_dbg("from %s.\n", pathname);
+			ret = cgroup_add_cgroup_templates(
+				template_table_last_index);
+			if (ret) {
+				cgroup_dbg("Unable to copy cgroup\n");
+				*file_index = j;
+				return ret;
+			}
+			cgroup_dbg("Templates to template table copied\n");
+		}
+	}
+
+	return 0;
+}
+
 /*
  * Create a given cgroup, based on template configuration if it is present
  * if the template is not present cgroup is creted using cgroup_create_cgroup
@@ -1592,13 +1760,16 @@ int cgroup_config_create_template_group(struct cgroup *cgroup,
 	 * use CGCONFIG_CONF_FILE by default
 	 */
 	if (!(flags & CGFLAG_USE_TEMPLATE_CACHE)) {
+		int fileindex;
 		if (template_table_index == 0)
 			/* the rules cache is empty */
-			ret = cgroup_init_templates_cache(CGCONFIG_CONF_FILE);
+			ret = cgroup_load_templates_cache_from_files(
+				&fileindex);
+
 		else
 			/* cache is not empty */
-			ret = cgroup_reload_cached_templates(
-				CGCONFIG_CONF_FILE);
+			ret = cgroup_load_templates_cache_from_files(
+				&fileindex);
 		if (ret != 0) {
 			cgroup_dbg("Failed initialize templates cache.\n");
 			return ret;
@@ -1679,3 +1850,80 @@ int cgroup_config_create_template_group(struct cgroup *cgroup,
 end:
 	return ret;
 }
+
+/**
+ * Initialize and load template rules from /etc/cgconfig.conf
+ * and /etc/cgconfig.d directory
+ */
+int cgroup_init_template_files(struct cgroup_string_list **tmpl_files,
+		int *fileindex, char *program_name)
+{
+	int ret;
+
+	*tmpl_files = malloc(sizeof(struct cgroup_string_list));
+	if (! *tmpl_files) {
+		last_errno = errno;
+		ret = ECGOTHER;
+		goto error;
+	}
+
+	if ((ret = cgroup_string_list_init(*tmpl_files,
+			CGCONFIG_CONF_FILES_LIST_MINIMUM_SIZE)) != 0) {
+		fprintf(stderr, "%s: cannot init file list, out of memory?\n",
+			program_name);
+		goto error_init;
+	}
+
+	/* first add CGCONFIG_CONF_FILE into file list */
+	if ((ret = cgroup_string_list_add_item(*tmpl_files,
+			CGCONFIG_CONF_FILE)) != 0) {
+		fprintf(stderr, "%s: cannot add file to list, out of memory?\n",
+			program_name);
+		goto error_list_init;
+	}
+
+	/* then read CGCONFIG_CONF_DIR directory for additional config files */
+	if ((ret = cgroup_string_list_add_directory(*tmpl_files,
+			CGCONFIG_CONF_DIR, program_name)) != 0) {
+		fprintf(stderr, "%s: cannot add files to list, out of memory?\n",
+			program_name);
+		goto error_list_init;
+	}
+
+	/* ask libcgroup to load template rules */
+	cgroup_templates_cache_set_source_files(*tmpl_files);
+	if ((ret = cgroup_load_templates_cache_from_files(fileindex)) != 0) {
+		if (*fileindex < 0) {
+			fprintf(stderr, "%s: template source files have not been set.\n",
+				program_name);
+		} else {
+			fprintf(stderr, "%s: failed to initialize template rules from %s.\n",
+				program_name, (*tmpl_files)->items[*fileindex]);
+		}
+		goto error_list_init;
+	}
+
+	return 0;
+
+error_list_init:
+	cgroup_string_list_free(*tmpl_files);
+error_init:
+	free(*tmpl_files);
+error:
+	*tmpl_files = NULL;
+	*fileindex = -1;
+
+	return ret;
+}
+
+/**
+ * Free list of template config files
+ */
+void cgroup_free_template_files(struct cgroup_string_list **tmpl_files)
+{
+	if (*tmpl_files) {
+		cgroup_string_list_free(*tmpl_files);
+		free(*tmpl_files);
+		*tmpl_files = NULL;
+	}
+}
diff --git a/src/daemon/cgrulesengd.c b/src/daemon/cgrulesengd.c
index 170837a..4f6e58c 100644
--- a/src/daemon/cgrulesengd.c
+++ b/src/daemon/cgrulesengd.c
@@ -59,6 +59,9 @@
 
 #define NUM_PER_REALLOCATIOM	(100)
 
+/* list of config files from CGCONFIG_CONF_FILE and CGCONFIG_CONF_DIR */
+static struct cgroup_string_list *template_files = NULL;
+
 /* Log file, NULL if logging to file is disabled */
 FILE* logfile;
 
@@ -936,6 +939,8 @@ void cgre_flash_rules(int signum)
 	/* Current time */
 	time_t tm = time(0);
 
+	int fileindex;
+
 	flog(LOG_INFO, "Reloading rules configuration\n");
 	flog(LOG_DEBUG, "Current time: %s\n", ctime(&tm));
 
@@ -949,7 +954,7 @@ void cgre_flash_rules(int signum)
 	}
 
 	/* Ask libcgroup to reload the template rules table. */
-	cgroup_reload_cached_templates(CGCONFIG_CONF_FILE);
+	cgroup_load_templates_cache_from_files(&fileindex);
 }
 
 /**
@@ -962,11 +967,13 @@ void cgre_flash_templates(int signum)
 	/* Current time */
 	time_t tm = time(0);
 
+	int fileindex;
+
 	flog(LOG_INFO, "Reloading templates configuration.\n");
 	flog(LOG_DEBUG, "Current time: %s\n", ctime(&tm));
 
 	/* Ask libcgroup to reload the templates table. */
-	cgroup_reload_cached_templates(CGCONFIG_CONF_FILE);
+	cgroup_load_templates_cache_from_files(&fileindex);
 }
 
 /**
@@ -1069,6 +1076,8 @@ int main(int argc, char *argv[])
 		{NULL, 0, NULL, 0}
 	};
 
+	int fileindex;
+
 	/* Make sure the user is root. */
 	if (getuid() != 0) {
 		fprintf(stderr, "Error: Only root can start/stop the control"
@@ -1179,7 +1188,6 @@ int main(int argc, char *argv[])
 		goto finished;
 	}
 
-	/* Ask libcgroup to load the configuration rules. */
 	if ((ret = cgroup_init_rules_cache()) != 0) {
 		fprintf(stderr, "Error: libcgroup failed to initialize rules"
 				"cache from %s. %s\n", CGRULES_CONF_FILE,
@@ -1187,14 +1195,12 @@ int main(int argc, char *argv[])
 		goto finished;
 	}
 
-	/* ask libcgroup to load template rules as well */
-	ret = cgroup_init_templates_cache(CGCONFIG_CONF_FILE);
-	if (ret != 0) {
-		fprintf(stderr, "Error: libcgroup failed to initialize teplate"\
-				"rules from %s. %s\n", CGCONFIG_CONF_FILE,
-				cgroup_strerror(ret));
+    if ((ret = cgroup_init_template_files(&template_files, &fileindex,
+			argv[0])) != 0) {
+		fprintf(stderr, "Error: libcgroup failed to initialize"
+				"template rules, %s\n", cgroup_strerror(ret));
 		goto finished;
-	}
+    }
 
 	/* Now, start the daemon. */
 	ret = cgre_start_daemon(logp, facility, daemon, verbosity);
@@ -1259,6 +1265,8 @@ int main(int argc, char *argv[])
 	ret =  cgre_create_netlink_socket_process_msg();
 
 finished:
+	cgroup_free_template_files(&template_files);
+
 	if (logfile && logfile != stdout)
 		fclose(logfile);
 
diff --git a/src/libcgroup-internal.h b/src/libcgroup-internal.h
index 4c0f46c..c128788 100644
--- a/src/libcgroup-internal.h
+++ b/src/libcgroup-internal.h
@@ -48,6 +48,9 @@ __BEGIN_DECLS
 
 
 #define CGCONFIG_CONF_FILE		"/etc/cgconfig.conf"
+/* Minimum number of file in template file list for cgrulesengd */
+#define CGCONFIG_CONF_FILES_LIST_MINIMUM_SIZE   4
+#define CGCONFIG_CONF_DIR               "/etc/cgconfig.d"
 
 #define CGRULES_CONF_FILE       "/etc/cgrules.conf"
 #define CGRULES_MAX_FIELDS_PER_LINE		3
diff --git a/src/libcgroup.map b/src/libcgroup.map
index b0c162c..e114c13 100644
--- a/src/libcgroup.map
+++ b/src/libcgroup.map
@@ -117,3 +117,10 @@ CGROUP_0.39 {
 	cgroup_log;
 	cgroup_parse_log_level_str;
 } CGROUP_0.38;
+
+CGROUP_0.40 {
+	cgroup_templates_cache_set_source_files;
+	cgroup_load_templates_cache_from_files;
+	cgroup_init_template_files;
+	cgroup_free_template_files;
+} CGROUP_0.39;
diff --git a/src/pam/pam_cgroup.c b/src/pam/pam_cgroup.c
index aa0bd62..10021e4 100644
--- a/src/pam/pam_cgroup.c
+++ b/src/pam/pam_cgroup.c
@@ -75,6 +75,13 @@
 
 #define PAM_DEBUG_ARG       0x0001
 
+/* program name for log messages */
+
+#define PROGRAM_NAME        "pam_cgroup.so"
+
+/* list of config files from CGCONFIG_CONF_FILE and CGCONFIG_CONF_DIR */
+static struct cgroup_string_list *template_files = NULL;
+
 static int _pam_parse(const pam_handle_t *pamh, int argc, const char **argv)
 {
     int ctrl = 0;
@@ -98,6 +105,7 @@ PAM_EXTERN int pam_sm_open_session(pam_handle_t *pamh, int flags,
 	int ctrl, ret;
 	char *user_name;
 	struct passwd *pwd;
+	int fileindex;
 
 	D(("called."));
 
@@ -129,6 +137,14 @@ PAM_EXTERN int pam_sm_open_session(pam_handle_t *pamh, int flags,
 		return PAM_SESSION_ERR;
 	}
 
+	ret = cgroup_init_template_files(&template_files, &fileindex, PROGRAM_NAME);
+	if (ret) {
+		if (ctrl & PAM_DEBUG_ARG)
+			pam_syslog(pamh, LOG_ERR, "libcgroup failed to initialize"
+				" template rules, %s\n", cgroup_strerror(ret));
+		return PAM_SESSION_ERR;
+	}
+
 	D(("Initialized libcgroup successfuly."));
 
 	/* Determine the pid of the task */
@@ -142,6 +158,7 @@ PAM_EXTERN int pam_sm_open_session(pam_handle_t *pamh, int flags,
 		if (ctrl & PAM_DEBUG_ARG)
 			pam_syslog(pamh, LOG_ERR, "Change of cgroup for process"
 				" with username %s failed.\n", user_name);
+		cgroup_free_template_files(&template_files);
 		return PAM_SESSION_ERR;
 	}
 
@@ -149,6 +166,7 @@ PAM_EXTERN int pam_sm_open_session(pam_handle_t *pamh, int flags,
 		pam_syslog(pamh, LOG_DEBUG, "Changed cgroup for process %d"
 				"  with username %s.\n", pid, user_name);
 
+	cgroup_free_template_files(&template_files);
 	return PAM_SUCCESS;
 }
 
diff --git a/src/tools/tools-common.h b/src/tools/tools-common.h
index e05465f..c723eb4 100644
--- a/src/tools/tools-common.h
+++ b/src/tools/tools-common.h
@@ -20,7 +20,7 @@
 
 #include "config.h"
 #include <libcgroup.h>
-#include <libcgroup-internal.h>
+#include "../libcgroup-internal.h"
 
 #define cgroup_err(x...) cgroup_log(CGROUP_LOG_ERROR, x)
 #define cgroup_warn(x...) cgroup_log(CGROUP_LOG_WARNING, x)
-- 
2.7.4

